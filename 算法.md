# 算法

## 一.排序算法

### 1.桶排序

**方法**：

***例如***,给`5,3,5,2,8`排序(数的范围为`0~10`)

1. 申请一个一维数组`a[11]`

   ```c
   a[0]=0
   a[1]=0
   ......
   a[10]=0
   ```

2. 开始**计数**
   | 数字 | 出现次数 | 数组值 | 打印数 |
   | :--: | :------: | :----: | :----: |
   |  2   |   一次   |   2    |  一次  |
   |  3   |   一次   |   3    |  一次  |
   |  5   |   两次   |   5    |  两次  |
   |  8   |   一次   |   8    |  一次  |

3. **具体代码**:

   ```c++
   //从小到大
   #include <stdio.h>
   #include <stdlib.h>
   
   int main()
   {
       int a[11]={0};//初始化
       int t;//计数
   
       //录入5,3,5,2,8
       for (int i = 1; i <= 5 ; i++)//循环五次
       {
           scanf("%d",&t);
           a[t]++;//计数
       }
       
       for (int i = 0; i < 11; i++)//遍历a[0]~a[10]
       {
          
           for (int j = 1; j <= a[i]; j++)//需要打印几次
           {
               printf("%d ",i);
           }
               
           
       }
       system("pause");
       return 0;
       
   }
   ```

   ```c++
   //从大到小
   #include <stdio.h>
   #include <stdlib.h>
   
   int main()
   {
       int a[11]={0};//初始化
       int t;//计数
   
       //录入5,3,5,2,8
       for (int i = 1; i <= 5 ; i++)//循环五次
       {
           scanf("%d",&t);
           a[t]++;//计数
       }
       
       for (int i = 10; i >= 0; i--)//遍历a[10]~a[0]
       {
          
           for (int j = 1; j <= a[i]; j++)//需要打印几次
           {
               printf("%d ",i);
           }
               
           
       }
       system("pause");
       return 0;
       
   }
   ```

   

**思考**:如果是0~1000范围呢?

1. **定义**一个大小为`1001`的数组

2. **数组的本质**:标记这个数出现的次数

3. **book[]**本身有标记的意思

4. **具体代码**:

   ```c
   //范围是1000以内的数
       int book[1001]={0};
       int n;//表示需要输入多少个数
       scanf("%d",&n);
   
   
       //然后和前面一样
       for (int i = 1; i <= n ; i++)//循环n次
       {
           scanf("%d",&t);
           book[t]++;//计数
       }
       
       for (int i = 0; i <=1000; i++)//遍历a[0]~a[1000]
       {
          
           for (int j = 1; j <= book[i]; j++)//需要打印几次
           {
               printf("%d ",i);
           }
               
           
       }
   
       printf("\n");
   
       for (int i = 1000; i >= 0; i--)//遍历a[1000]~a[0]
       {
           for (int j = 1; j <= book[i]; j++)//需要打印几次
           {
               printf("%d ",i);
           }         
           
       }
   ```

**缺点**:

1. 不能排序**字母**
2. 浪费**空间**(book[1001])
3. 只能是**正整数**
***

### 2.冒泡排序

**方法**：

***例题***： 将`12 35 99 18 76`**从大到小**排序

1. **最小数**归位

   | 比较的两个数 | 是否替换 |      结果      |
   | :----------: | :------: | :------------: |
   |    12 35     |  35,12   | 35 12 99 18 76 |
   |    12 99     |  99,12   | 35 99 12 18 76 |
   |    12 18     |  18 12   | 35 99 18 12 76 |
   |    12 76     |  76 12   | 35 99 18 76 12 |

2. **第二小数**归位

   | 比较的两个数 | 是否替换 |      结果      |
   | :----------: | :------: | :------------: |
   |    35 99     |  99 35   | 99 35 18 76 12 |
   |    35 18     |  35 18   | 99 35 18 76 12 |
   |    18 76     |  76 18   | 99 35 76 18 12 |

   少判断一次,因为**已经归位的数不用比较**

3. **第三小数**归位

   | 比较的两个数 | 是否替换 |      结果      |
   | :----------: | :------: | :------------: |
   |    99 35     |  99 35   | 99 35 76 18 12 |
   |    35 76     |  76 35   | 99 76 35 18 12 |

   同样.**又少了一次判断**

4. **第四小数**归位

   | 比较的两个数 | 是否替换 |      结果      |
   | :----------: | :------: | :------------: |
   |    99 76     |  99 76   | 99 76 35 18 12 |

**总结**:**五个数**的比较,用了**四轮判断**,第一轮判断了**四次**,次数随轮数**减一**

**具体代码**:

1. ```c
   //实现上述功能代码
   #include <stdio.h>
   #include <stdlib.h>
   
   int main()
   {
       int a[100]={0};//用来存储数据，和桶排序的数组意义不同
       int n;//n表示输入数的个数
       int temp;//用来做互换的变量
       scanf("%d",&n);
   
       //输入n个数
       for (int i = 1; i <= n; i++)//这么写的好处：第n个数存到a[n]中
       {
           scanf("%d",a+i);
       }
   
       //冒泡排序部分
       for (int i = 1; i <= n-1; i++)//n个数只需要进行n-1次判断
       {
           for (int j = 1; j <=n-i; j++)
           {
               /*
               1. 四次
               2. 三次
               3. 两次
               4. 一次
               */
               if (a[j]<a[j+1])//替换语法
               {
                   temp=a[j];
                   a[j]=a[j+1];
                   a[j+1]=temp;
               }           
           }
           
       }
       //输出排序后的数
       for (int i = 1; i <= n; i++)
       {
           printf("%d ",a[i]);
       }
       system("pause");
       return 0;
   }
   ```

2. ```c
   //输出排序后的数
       for (int i = 1; i <= n; i++)
       {
           printf("%d ",a[i]);
       }
   
       //含有字母的数字排序
       struct student
       {
           char name[21];
           int score;
       };//存储性别和分数
       struct student A[100];
       struct student temp2;//用于替换
       int N;
       scanf("%d",&N);
       //读入数据
       for (int i = 1; i <= N; i++)
       {
           scanf("%s %d",A[i].name,&A[i].score);
       }
       //从高到低
           for (int i = 1; i <= N-1; i++)//n个数只需要进行n-1次判断
       {
           for (int j = 1; j <= N-i; j++)
           {
               if (A[j].score<A[j+1].score)//替换语法
               {
                   temp2=A[j];
                   A[j]=A[j+1];
                   A[j+1]=temp2;
                   //并不是把两个个分数替换，而是把两个结构体替换
               }           
           }
           
       }
       //输出
       for (int i = 1; i <= N; i++)
       {
           printf("%s\n",A[i].name);
       }
   ```

**缺点**:**双重嵌套**,算法复杂度高,**浪费空间**

### 3.快速排序

**方法**:

***例题***:  将`6 1 2 7 9 3 4 5 10 8`排序

1. 找个**基准数**  `6`——用来做参照

2. 把`6`移到某个位置**K**——以K为分界线，左边小于6，右边大于6

3. **过程**:
   
   ```mermaid
   graph TB
    A(6) --> i
    a(1)
    b(2)
    c(7)
    d(9)
    e(3)
    f(4)
    g(5)
    h(10)
    B(8) --> j
    
   ```
   哨兵`i`,`j`从两端向内开始侦察,i侦察比6大的数，j侦察比6小的数
   
   ***
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(7) --> i
    d(9)
    e(3)
    f(4)
    g(5) --> j
    h(10)
    B(8) 
    
   ```
   此时，`i`找到了大于6的数，`j`找到了小于6的数
   
   ***
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(5) --> i
    d(9)
    e(3)
    f(4)
    g(7) --> j
    h(10)
    B(8) 
    
   ```
   将`7` `5`两个数交换位置
   
   ***
   
   继续像前侦察
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(5) 
    d(9) --> i
    e(3)
    f(4) --> j
    g(7) 
    h(10)
    B(8) 
   ```
   ***
   
   接着交换
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(5) 
    d(4) --> i
    e(3)
    f(9) --> j
    g(7) 
    h(10)
    B(8) 
   ```
   ***
   
   继续向前
   
   ```mermaid
   graph TB
    A(6) 
    a(1)
    b(2)
    c(5) 
    d(4) 
    e(3) --> i & j
    f(9) 
    g(7) 
    h(10)
    B(8) 
   ```
   此时,`i`和`j`相遇,是**侦察完成的标志**
   
   ***
   
   将基准数`6`与`3`交换
   
   ```mermaid
   graph TB
    A(3) 
    a(1)
    b(2)
    c(5) 
    d(4) 
    e(6) --> i & j
    f(9) 
    g(7) 
    h(10)
    B(8) 
   ```
   
   ***
   第一轮排序结束,以`6`为分界点拆成了两个**新序列**
   
   ```mermaid
   graph TB
    A(3) 
    a(1)
    b(2)
    c(5) 
    d(4) 
   ```
   ```mermaid
   graph TB
    f(9) 
    g(7) 
    h(10)
    B(8) 
   ```
   再将这两个序列**重复**以上的排序
   
4. **思想**:**二分**法(总的**比较**和**交换次数**变少了)

5. **注意**:一旦`i`和`j`碰到一起,就停止**移动**

6. **思考**:`i`和`j`谁先侦察的问题

   ***例***： 给`1 2 3 4 5`排序,基准数为`1`
   本例中，`i`找的是大于1的数,`j`找的是小于1的数
   
   ```mermaid
   graph TB
    A(1) --> i
    a(2)
    b(3)
    h(4)
    B(5) --> j
    
   ```
   分情况讨论:
   ```mermaid
   graph LR
     A1(i先走) --> B1(侦察到2大于1)-->B2(停下,等j走) -->B3(相遇)-->B6(1和2交换)
     A2(j后走) --> B4(没有小于1的数)-->B5(一直往前,直到遇见i)-->B3
   ```
   ```mermaid
   graph LR
     A1(j先走) --> B1(没有小于1的数)-->B3(一直走到尽头)-->B6(相遇)
     A2(i后走) --> B4(没开始侦察就撞见j)-->B6(相遇)-->B5(不交换)
   ```
   `j`先走明显才是符合题意的
   **总结**:
   
   基准数在**左边**,先移`j`
   
   基准数在**右边**,先移`i`

7. **具体代码**:

   ```c
   #include <stdio.h>
   #include <stdlib.h>

   int a[101],n;//定义一个数组储存数据,n为数据个数
   
   void quick_sort(int left,int right)
   {
       if (left>=right)
       {
           return;
       }
       
       int temp;//用于基准数替换
       temp=a[left];//先存起来
       int i=left,j=right;
       while (i!=j)//侦察兵没有相遇,就重复执行
       {
           //先是j侦察,a[j]<temp停下来,相遇的话就不用再动了
           while (a[j]>=temp&&i!=j)
           {
               j--;
           }
           //i开始侦察，相遇的话就不用再动了
           while (a[i]<=temp&&i!=j)
           {
               i++;
           }
           //如果没有相遇，交换两个数
           if (i!=j)
           {
               int t;
               t=a[i];
               a[i]=a[j];
               a[j]=t;
           }
           
       }
       //开始替换
       a[left]=a[i];
       a[i]=temp;//用a[j]也是可以的
   
       //处理左边剩下的
       quick_sort(left,i-1);
       //处理右边剩下的
       quick_sort(i+1,right);//用j也是可以的
   
   }
   int main()
   {
       scanf("%d",&n);//输入个数
       for (int i = 1; i <= n; i++)
       {
           scanf("%d",a+i);
       }
       
       quick_sort(1,n);//排序函数
   
       //输出结果
       for (int i = 1; i <= n; i++)
       {
           printf("%d ",a[i]);
       }
   
       return 0;
   }
   ```
   

**优点**:**速度**快，不占**空间**

## 二.栈，队列，链表

### 1.解密qq号,队列

***例***:一个**加密过**的qq号`6 3 1 7 5 8 9 2 4`

1. **加密规则**:第一个数删除,第二个数放末尾,第三个数删除,第四个数放末尾......将**删除的数**按照顺序排列

2. **加密过程**:

   ```mermaid
    graph TB
    a(6)-->delte
    b(3)-->move
    c(1)
    d(7)
    e(5)
    f(8)
    g(9)
    h(2)
    i(4)
   ```
   ```mermaid
    graph TB
    
    
    c(1)-->delte
    d(7)-->move
    e(5)
    f(8)
    g(9)
    h(2)
    i(4)
    b(3)
   ```
   ```mermaid
    graph TB
    
    
    
    
    e(5)-->delte
    f(8)-->move
    g(9)
    h(2)
    i(4)
    b(3)
    d(7)
   ```
   ```mermaid
    graph TB
    
    
    g(9)-->delte
    h(2)-->move
    i(4)
    b(3)
    d(7)
    f(8)
   ```
   ```mermaid
    graph TB
    
    
    i(4)-->delte
    b(3)-->move
    d(7)
    f(8)
    h(2)
   ```
   ```mermaid
    graph TB
    
    
    
    
    d(7)-->delte
    f(8)-->move
    h(2)
    b(3)
   ```
   ```mermaid
    graph TB
    
    
    
    
    h(2)-->delte
    b(3)-->move
    f(8)
   ```
   ```mermaid
    graph TB
    
    
    f(8)-->delte
    b(3)-->move
    
    
   ```
   ```mermaid
    graph TB
    
    
    b(3)-->delte
    
   ```
   **最后将`delete`的数按顺序输出**
   
   ```mermaid
    graph TB
    a(6)
    b(1)
    c(5)
    d(9)
    e(4)
    f(7)
    g(2)
    h(8)
    i(3)
   ```

3. **算法**:

   * 定义一个数组`q[101]`

   * `q[101]`=`{0,6,3,1,7,5,8,9,2,4}`

   * 引入两个整形**变量**;

     `head`记录队列的**队首**

     `tail`j记录队列的**队尾**的**后一位**

   * 一个循环
   
     | q[0] | q[1] | q[2] | q[3] | q[4] | q[5] | q[6] | q[7] | q[8] | q[9] | q[10] | q[11] |
     | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :---: | :---: |
     |  0   |  6   |  3   |  1   |  7   |  5   |  8   |  9   |  2   |  4   |       |       |
     |      | head |      |      |      |      |      |      |      |      | tail  |       |
     |  0   |  6   |  3   |  1   |  7   |  5   |  8   |  9   |  2   |  4   |       |       |
     |      |      | head |      |      |      |      |      |      |      | tail  |       |
     |  0   |  6   |  3   |  1   |  7   |  5   |  8   |  9   |  2   |  4   |   3   |       |
     |      |      | head |      |      |      |      |      |      |      |       | tail  |
     |  0   |  6   |  3   |  1   |  7   |  5   |  8   |  9   |  2   |  4   |   3   |       |
     |      |      |      | head |      |      |      |      |      |      |       | tail  |
   
   
   * **代码实现**
   
     ```c
     #include <stdio.h>
     int main()
   {
         int q[101]={0,6,3,1,7,5,8,9,2,4};//定义一个数组来储存
         int head=1;//记录首个元素
         int tail=10;//记录队尾的后一个元素,这样两个变量重合时为空，也方便数的转移
         while (head!=tail)//队列有元素时执行(不为空队列时)
         {
             //打印头元素
             printf("%d ",q[head]);
             //出队
             head++;
     
             //加到队尾
             q[tail]=q[head];
             tail++;
             //出队
             head++;
         }
         
         //结构体封装
         struct 
         {
             int data[101];
             int head1;
             int tail1;
         }queue;
     
         int n;
         scanf("%d",&n);
         int i;
         for (i = 1; i <= n; i++)
         {
             scanf("%d",&queue.data[i]);
         }
         queue.head1=1;
         queue.tail1=i;// =n+1
         //后面和前面同理
         while (queue.head1!=queue.tail1)
         {
             printf("%d ",queue.data[queue.head1]);
             queue.head1++;
             queue.data[queue.tail1]=queue.data[queue.head1];
             queue.tail1++;queue.head1++;
         }
         
         return 0;
     }
     ```
   
4. **队列的本质**:**前端**出,**后端**进     

### 2.解密回文,栈

1. **生活**中的**栈**:薯片桶.弹夹......

2. **栈**的本质:只能在**一端**插入或删除

3. 如何实现一个**栈**

   * **一维**数组+**变量**top

4. ***例题***:判断是否为**回文**

   * **回文**的**定义**:"yxcxy""aha""席主席"这类**中间对称**的数

   * 读出回文的**长度**

   * 求**中点**

   * 将**中点前面**的数**入栈**

   * 再**出栈**判断是否一一匹配

   * **代码**如下

     ```c
     #include <stdio.h>
     #include <string.h>
     
     int main()
     {
         char a[101];//键盘读入字符串
         char s[101];//栈
     
         /*
         计算长度,从a[1]开始记录(方便)
         例如，输入yxcxy||yxccxy
         a[1]=y
         a[2]=x
         a[3]=c
         a[4]=x
         a[5]=y
         */
         gets(a+1);
         int len=strlen(a+1);//len=5,6
     
         //栈的初始化
         int top=0;
         //中间值，这里是3
         int mid=(len+1)/2;//mid=3
         //将前一半yxc存入栈中
         int i = 1;
         for (; i <= mid ; i++)
         {
             s[i]=a[i];
         }
         /*
         s[1]=y
         s[2]=x
         s[3]=c
         */
         top=mid;//存到栈里面三个数
     
         //奇数和偶数的起始判断点不同
         i=(len%2)?mid:mid+1;
     
         //判断谁是回文
         for (; i <= len ; i++,top--)
         {
             if (a[i]!=s[top])
             {
                 break;
             }
         }
         printf("%s",(top)?"no":"yes");
         return 0;
     }
     ```

5. **其他应用**:检查编译器编译时**括号是否匹配**

### 3.链表

***例题***：一个从**小到大**排列的数字`2 3 5 8 9 10 18 26 32`,插入数字`6`仍然**符合排序**

1. 使用**数组**的方法

   **向后**挪一位,将`6`插入

   | 2    | 3    | 5    | 8    | 9    | 10   | 18   | 26   | 32   |      |
   | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 2    | 3    | 5    | 6    | 8    | 9    | 10   | 18   | 26   | 32   |

   **缺点**:耽误时间

2. 使用**链表**的方法

   ```mermaid
   graph LR
   2--> 3--> 5--> 8--> 9--> 10--> 18--> 26--> 32
   
   ```

   ```mermaid
   graph LR
   2--> 3--> 5--> 8
   9--> 10--> 18--> 26--> 32
   8-->a(6)-->9
   ```
   * 申请**动态内存**

     ```c
       #include <stdio.h>
       #include <stdlib.h>
       int main()
       {
           int *p;
           p=(int*)malloc(sizeof(int));
           //p指向一个int型的整数，是一个int类型的指针
           *p=10;
           printf("%d",*p);
           return 0;
       }
     ```

   * **数组**模拟**链表**

   1. 定义一个**结构体**存储**节点**

      **节点**=**data**+***next**
      
      ```mermaid
         graph LR
         a(data: 2)--*next-->b(data: 3)--*next-->c(...)
      ```
      
      ```c
         struct node
         {
             int data;//用来存放具体的数
             struct node *next;//存放下一个节点的地址
         }
      ```

   2. ```c
      //创建头指针,滞空(方便遍历)
      struct node *head=NULL;
      //创建第一个节点
      struct node *p;
      //申请一个空间存储节点
      p=(struct node*)malloc(sizeof(struct node));
      //创建data和*next
      scanf("%d",&a);
      p->data=a;
      p->next=NULL;
      //如果是第一个节点,让head指向它
      if(head==NULL)
          head=p;
      //如果不是第一个,让前一个节点的指针指向它
      else q->next=p;
      q=p;//指针q也指向节点
      ```

      ```mermaid
      graph LR
      a(data: 2)--*next-->NULL
      p-.->a
      head-.->p
      q-.->p
      ```
      
      ```mermaid
      graph LR
         a(data: 2)--*next-->b(data: 3)--*next-->NULL
         p-.->b
         head-.->a
         q-.->a
         q'-.->p
      ```
   3. **具体代码**

      ```c
      #include <stdio.h>
      #include <stdlib.h>
      
      struct node
      {
          int data;//用来存放具体的数
          //嵌套
          struct node *next;//存放下一个节点的地址
      };
      
      int main()
      {
          struct node *head,*p,*q,*t;
          int n,a;//a用来存储值
          scanf("%d",&n);//输入多少个数
          head=NULL;//滞空
          for (int i = 1; i <= n; i++)
          {
              scanf("%d",&a);
              //申请一个空间存储节点
              p=(struct node*)malloc(sizeof(struct node));
              //存储data
              p->data=a;
              //节点的继后指针为空
              p->next=NULL;
      
              if(head==NULL)
                head=p;
              //如果不是第一个,让前一个节点的指针指向它
              else q->next=p;
      
              q=p;//指针q也指向节点
          }
          //输出
          t=head;
          while (t!=NULL)
          {
              printf("%d ",t->data);
              t=t->next;
          }
          return 0;
      }
      ```
      
      接下来从链表中插入`6`
      
      ```c
          //插入数字6
          t=head;//开始遍历
          scanf("%d",&a);//插入6
          //寻找t下一个节点的data比6大时，插入，及t->next->data>6
          while (t!=NULL)
          {
              if (t->next->data>=a)
              {
                  p=(struct node*)malloc(sizeof(struct node));
                  p->data=a;
                  p->next=t->next;
                  t->next=p;
                  break;//退出循环
              }
              t=t->next;//下一个节点
          }
          
          //打印
          t=head;
          while (t!=NULL)
          {
              printf("%d ",t->data);
              t=t->next;
          }
      ```
      
      
      
   4. **模拟链表**

      * 再用一个数组`right`来存储`data`右边的数

      * | number of data | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
        | :------------: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
        | value of data  | 2    | 3    | 5    | 8    | 9    | 10   | 18   | 26   | 32   |      |

        | number of right | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |      9      | 10   |
        | :-------------: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | :---------: | ---- |
        | value of right  | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 0(表示结束) |      |

        **说明**:`data`用来存放**具体的数,**`right`右边元素在`data`中的**位置**,`right[1]=2`表示**1号**元素右边的值在**2号中**

        `right数组`的**意义**可以用以下图表示
  
        ```mermaid
  graph LR
        1-->2-->3-->4-->5-->6-->7-->8-->9-->0(0,表示结束)
        ```
        
      * ***例***:将`6`插入数组中
      
        | number of data | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
      | :------------: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
        | value of data  | 2    | 3    | 5    | 8    | 9    | 10   | 18   | 26   | 32   | 6    |
        
        `6`在`data[3]=5`后面
        
        `right[3]=10`表示**3号**元素右边的值在**10号中**
        
        | number of right | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
        | :-------------: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
        | value of right  | 2    | 3    | 10   | 5    | 6    | 7    | 8    | 9    | 0    | 4    |
        
        ```mermaid
        graph LR
        1-->2-->3-->10-->4-->5-->6-->7-->8-->9-->0
        ```
        
      * **具体代码**:
      
        ```c
        #include<stdio.h>
        
        int main()
        {
            int data[101],right[101];
            int n,t,len;
            scanf("%d",&n);//要输入多少个数
            for (int i = 1; i <= n; i++)
            {
                scanf("%d",data+i);
            }
            
            //初始化right
            for (int i = 1; i <= n; i++)
            {
                if (i!=n)
                {
                    right[i]=i+1;
                }
                else right[i]=0;
            }
            
            len=n+1;//数组扩展一位，用于输入要插入的数
            //输入6
            scanf("%d",data+len);
        
            //开始遍历
            t=1;
            while (t!=0)//right[n]=0
            {
                if (data[right[t]]>=data[len])//data[right[3]]=8>6
                {
                    right[len]=right[t];//right[10]=right[3]
                    right[t]=len;//right[3]=10
                    break;//跳出当前循环
                }
                t=right[t];//向后挪
            }
            
            //打印数组
            t=1;
            while (t!=0)
            {
                printf("%d ",data[t]);
                t=right[t];//向后挪
            }
            return 0;
        
        }
        ```
      
        

